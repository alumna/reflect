"use strict";var e=require("fs"),i=require("util");const t=i.promisify(e.copyFile),s=i.promisify(e.mkdir),r=i.promisify(e.readdir),a=i.promisify(e.rmdir),c=i.promisify(e.stat),h=i.promisify(e.unlink),n=i.promisify(e.utimes);class o{constructor(e,i,t,s,r){this.cache={},this.exclude={},this.recursive=e,this.delete=i,this.modified_within=null!==t&&Date.now()/1e3-t,this.only_newer=s,this.file_clone=r}async start(e,i,t){return e&&i?"string"!=typeof e||"string"!=typeof i?{res:!1,err:"Parameters 'src' and 'dest' must be string paths"}:(e=this.fix(e),i=this.fix(i),await this.prepare(e,"src")&&await this.prepare(i,"dest")?(t.forEach(i=>this.exclude[e+"/"+i]=!0),await this.walk(e,i),{res:'Directory "'+e+'" reflected to "'+i+'"',err:!1}):{res:!1,err:"Parameters 'src' and 'dest' must be a directory"}):{res:!1,err:"Parameters 'src' and 'dest' must be defined"}}async prepare(e,i){return!!await this.is_dir(e)||!await this.read(e)&&("src"!=i&&(this.cache[e]=!0,await s(e),!0))}async walk(e,i){const t=[],s=await r(e),a=await r(i);if(this.delete&&a.length){const e={};s.forEach(i=>e[i]=!0);a.filter(t=>!e[t]&&!this.exclude[i+"/"+t]).forEach(e=>t.push(this.remove(i+"/"+e)))}return s.forEach(s=>t.push(this.sync(e+"/"+s,i+"/"+s))),Promise.all(t)}async sync(i,s){return!!this.exclude[i]||(await this.is_dir(i)?!this.recursive||(await this.prepare(s,"dest"),this.walk(i,s)):!(!await this.read(s)||this.is_different(i,s))||(await t(i,s,this.file_clone?e.constants.COPYFILE_FICLONE:void 0),n(s,this.cache[i].atime,this.cache[i].mtime)))}async read(e){if(void 0===this.cache[e])try{return this.cache[e]=await c(e)}catch(i){return this.cache[e]=!1,!1}return this.cache[e]}async remove(e){if(!await this.is_dir(e))return this.cache[e]=!1,h(e);const i=await r(e);return await Promise.all(i.map(i=>this.remove(e+"/"+i))),this.cache[e]=!1,a(e)}async is_dir(e){return!!await this.read(e)&&this.cache[e].isDirectory()}is_different(e,i){const t=this.cache[e].mtime.getTime()/1e3,s=this.cache[i].mtime.getTime()/1e3;return this.only_newer?t>s:!1!==this.modified_within?t>=this.modified_within&&t!==s:this.cache[e].size!=this.cache[i].size||t!==s}fix(e){const i=e.slice(-1);return"/"==i||"\\"==i?e.slice(0,-1):e}}module.exports=function({src:e,dest:i,recursive:t=!0,delete:s=!0,exclude:r=[],modified_within:a=null,only_newer:c=!1,file_clone:h=!0}){return new o(t,s,a,c,h).start(e,i,r)};
